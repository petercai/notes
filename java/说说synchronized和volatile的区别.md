# 说说synchronized和volatile的区别
**synchronized和volatile的区别**

Java内存模型(JMM)
-------------

提到这两个有关于线程的关键字，那么我们不得不提到`Java`的内存模型了(JMM)，下面我们先看一下 **Java内存模型** 在处理多线程方面的工作原理图。

![](_assets/688335a2cb764bca973782cf8d8cf5b6~tplv-k3u1fbpfcp-zoom-in-crop-mark!1512!0!0!0.awebp.webp)

**Java内存模型(java Memory Model)** 描述了`Java`程序中各种变量(线程共享变量)的访问规则，以及在`JVM`中将变量存储到内存和从内存中读取出变量这样的底层细节。

### ✔两个重要概念

**可见性**：一个线程对共享变量值的修改，能够及时地被其他线程看到。  
**共享变量**：如果一个变量在多个线程的工作内存中都存在副本，那么这个变量就是这几个线程的共享变量。

**共享变量可见性实现的原理**

线程1对共享变量的修改要想被线程2及时看到，必须要经过如下两个步骤:

*   把工作内存1中更新过的共享变量刷新到主内存中
*   将主内存中最新的共享变量的值更新到工作内存2中

下图为一个共享变量实现可见性原理的一个示例：

![](_assets/fad1562f62e04918965f99b7a2767e9e~tplv-k3u1fbpfcp-zoom-in-crop-mark!1512!0!0!0.awebp.webp)

其中，线程对共享变量的操作，遵循以下两条规则:

*   线程对共享变量的所有操作都必须在自己的工作内存中进行，不能直接从主内存中读写
*   不同线程之间无法直接访问其他线程工作内存中的变量，线程间变量值的传递需要通过主内存来完成

**可见性**

要实现共享变量的可见性，必须保证两点：

*   线程修改后的共享变量值能够及时从工作内存刷新到主内存中
*   其他线程能够及时把共享变量的最新值从主内存更新到自己的工作内存中

**可见性的实现方式**

*   synchronized
*   volatile

synchronized关键字
---------------

### synchronoized实现可见性

*   原子性（同步）
*   可见性

### JMM关于synchronized的两条规定

*   线程解锁前，必须把共享变量的最新值刷新到主内存中
*   线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时，需要从主内存中重新读取最新的值(注意：加锁与解锁需要是同一把锁)

> 注意：线程解锁前对共享变量的修改在下次加锁时对其他线程可见

### synchronized的作用范围

*   **饰实例方法:** 作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁
*   **修饰静态方法:** 也就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员（ static 表明这是该类的一个静态资源，不管new了多少个对象，只有一份）。所以如果一个线程A调用一个实例对象的非静态 synchronized 方法，而线程B需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，**因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁**。
*   **修饰代码块:** 指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。

### 线程执行互斥代码的过程

1.  获得互斥锁
2.  清空工作内存
3.  从主内存拷贝变量的最新副本到工作的内存
4.  执行代码
5.  将更改后的共享变量的值刷新到主内存
6.  释放互斥锁

### 重排序

代码书写的顺序与实际执行的顺序不同，指令重排序是编译器或处理器为了提高程序性能而做的优化

*   编译器优化的重排序（编译器优化）
*   指令级并行重排序（处理器优化）
*   内存系统的重排序（处理器优化）

volatile关键字
-----------

### volatile实现可见性

*   `volatile`关键字能够保证`volatile`变量的可见性
*   不能保证`volatile`变量复合操作的原子性

### volatile如何实现内存可见性

深入来说：通过加入内存屏障和禁止重排序优化来实现的

*   对`volatile`变量执行写操作时，会在写操作后加入一条`store`屏障指令
*   对`volatile`变量执行读操作时，会在读操作前加入一条`load`屏障指令

### 线程写volatile变量的过程

1.  改变线程工作内存中`volatile`变量副本的值
2.  将改变后的副本的值从工作内存刷新到主内存

线程读`volatile`变量的过程

1.  从主内存中读取`volatile`变量的最新值到线程的工作内存中
2.  从工作内存中读取`volatile`变量的副本

下图是`volatile`不能实现原子性的示例：

```java
volatile不能保证volatile变量复合操作的原子性：

private int number = 0;                                    
number++; 
  
  
加入synchronized，变为原子操作：
synchronized(this) {
   number++;
}

```

实现原子操作解决方案
----------

保证`number`自增操作的原子性：

*   使用`synchronized`关键字
*   使用`ReentrantLock`
*   使用`AtomicInteger`

### 可重入锁案例

```csharp

public int increase(){
    lock.lock();
    try {
         number++;
    } finally {
         lock.onlock();
    }
}

```

### volatile适用场合

要在多线程中安全的使用`volatile`变量，必须同时满足：

*   对变量的写入操作不依赖其当前值
    *   不满足：number++、count=count*5 等
    *   满足：`boolean`变量、记录温度变化的变量等
*   该变量没有包含在具有其他变量的不变式中

总结
--

### synchronized和volatile的区别

1.  `volatile`不需要加锁，比`synchronized`更轻量级，不会阻塞线程；
2.  从内存可见性角度，`volatile`读相当于加锁，`volatile`写相当于解锁；
3.  `synchronized`既能够保证可见性，又能保证原子性，而`volatile`只能保证可见性，无法保证原子性。