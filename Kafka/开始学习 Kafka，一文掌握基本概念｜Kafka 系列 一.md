# 开始学习 Kafka
为什么学习 Kafka
-----------


对于当下环境来说，各个公司尤其是互联网公司的数据量越来越大，需要存储和处理大量的数据，但是计算机的瞬时处理能力是有限的，这就需要一款消息引擎来帮助我们缓解流量激增的问题，平滑将数据传导到下游系统中。

消息引擎系统是一组规范：企业利用这组规范在不同系统之间传递语义准确的消息，实现松耦合的异步式数据传递。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13eba0c52dc5409cafbf8ba707370dcb~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1598&h=896&s=141617&e=png&b=ffffff)

作为一款消息引擎，它主要有以下使用场景。

*   **异步处理**：同步调用转换成异步消息通知，在消费者种实现对应的业务处理。比如在一个交易场景中，系统的调用链路很长，订单创建完成后需要检查商品的库存、扣库存、发短信、App 通知等功能，如果都放在一个接口同步调用，接口响应时间会变得很长。但是如果把这些逻辑都利用消息引擎做异步处理逻辑将变得很轻量级。
*   **应用解耦**：减少应用直接的强依赖，利用消息队列通信，从而变成一种松耦合的结构。比如如果用户注册系统和红包系统利用接口同步通信，红包系统挂掉用户将无法注册，造成巨大损失。但是如果用户注册后发出一条注册消息，红包系统恢复后慢慢去消费，则可以解耦，提高系统的可用性。
*   **削峰填谷**：利用消息中间件缓冲上游生产者大量流量，从而使消费者消费流量整体平滑。对于消息生产能力很强的上游系统，如果没有消息中间件的保护，下游系统可能会直接被压垮导致全链路服务雪崩。比如秒杀业务场景，上游业务发起下单请求，下游业务执行秒杀业务（库存检查，库存冻结，余额冻结，生成订单等等），下游业务处理的逻辑是相当复杂的，并发能力有限，如果上游服务不做限流策略，瞬时可能把下游服务压垮。针对此场景，我们可以利用 MQ 来做削峰填谷，让高峰流量填充低谷空闲资源，达到系统资源的合理利用。

综合以上场景，这就要求一款消息引擎需要具备高可靠、高性能的特点，Kafka 就满足这样的要求。

设计消息系统应该注意什么？
-------------

消息系统的不同成员之间需要利用消息进行信息的传递，这就涉及到两个重要的内容：

1.  消息传递的格式是什么？
2.  消息是如何传递的，协议是什么？

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df4bff7b05034033b2a05b3c344c4c45~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=484&h=610&s=34594&e=png&b=fcfcfc)

消息传递的格式选择有很多，比如 JSON、XML、Protobuf 等，对于 Kafka 来说，他使用的是纯二进制的字节序列，当然消息还是结构化的，只是在使用之前都要将其转换成二进制的字节序列。

消息系统中，有两种常用的传输协议，点对点模型和发布订阅模型。这两种协议，Kafka 都支持。

1.  **点对点模型**：也叫消息队列模型。一个系统发送方发送的消息只能被指定接收方接收，其他任何系统都不能再读取 发送的消息。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e333056622584b87ae5481f8bc3f9000~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=422&h=620&s=25940&e=png&b=fefefe)

2.  **发布 / 订阅模型**：有一个主题（Topic）的概念，发送方也称为发布者（Publisher），接收方称为订阅者（Subscriber）。和点对点模型不同的是，这个模型可能存在多个发布者向相同的主题发送消息，而订阅者也可能存在多个，它们都能接收到相同主题的消息。举个例子，杂志订阅就是一种典型的发布 / 订阅模型，不同的居民可以订阅相同的杂志。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c130bf0d207b499ab390e5d70412e69a~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=916&h=616&s=36342&e=png&b=fcfcfc)

生产者和消费者
-------

学习 kafka 首先要明白其涉及的概念和术语，这是进入 Kafka 世界的门票。

作为一款消息系统，Kafka 提供了完整的消息发布和订阅解决方案。与其他消息系统一样，在这个系统中会有生产者和消费者以及 Topic 的角色。

*   消息(Record)：信息传递的载体。
    
*   生产者(Producer)：向一个或多个 Topic 发布消息的应用程序。
    
*   消费者(Consumer)：订阅一个或多个 Topic 接收消息的应用程序。
    
*   主题(Topic)：发布订阅的主题，同类型消息存储在同样的主题中，是一个逻辑上的划分，区分不同的业务。
    

消费者和生产者都是**客户端**（Clients），既然有客户端就有**服务端**。

Broker 服务端
----------

服务实例(Broker)：Kafka 的服务器端由被称为 Broker 的服务进程构成，一个 Kafka 集群由多个 Broker 组成。

Broker 负责接收和处理客户端发送过来的请求，以及对消息进行持久化。Broker 通常分散运行在不同的机器上，这样如果集群中某一台机器宕机，其他机器上的 Broker 也可以对外提供服务。这种多个 Broker 部署方式的方式保证了 Kafka 的高可用。 ![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/50b77069b23e4fceb22bdf9f9f8c5ff0~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=516&h=434&s=34971&e=png&b=fcfcfc)

分片和副本
-----

分区or 分片(Partition)：。kafka 将 一个Topic 中的消息分成多份，分别存储在不同的 Broker 里，这每一段消息被 kafka 称为 Partition。 每个 Partition 都一个有序不变的消息序列，每个 Topic 下可以有多个 Partition。多个分片满足**可扩展性**和**负载均衡**。

为什么要有 Partition？

因为一个 Topic 中的消息可能非常多，多到一台Broker存不下，因此需要拆分成多段存储在不同的机器里，并且这样做还能**提高读写性能**。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89dd8cbd8d3c4dec8d3b91460ae16557~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1808&h=794&s=216077&e=png&b=f7f5f4)

*   副本(Replica)：Kafka 中同一条消息能够被拷贝多份冗余存储，也就是副本。副本分为领导者副本（Leader Replica）和追随者副本（Follower Replica）。副本是在分区层级下的，即每个分区可配置多个副本实现高可用。（默认分区副本数不得超过kafka节点数），**多个副本满足高可用**，副本数量越多，可靠性越高。
    *   领导者副本（Leader Replica）：只有Leader能对客户端提供服务。生产者总是向领导者副本写消息，消费者总是从领导者副本读消息。
    *   追随者副本（Follower Replica）：Follower 只能向领导者副本发送请求，请求领导者把最新生产的消息发给它，这样它能保持与领导者的同步，不对客户端提供服务。

位移
--

由于 Kafka 中的消息都是增量存储的，所以读取和消费消息都有一个位移的概念。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/910bce2b3af34e3b892f4b1a1162d092~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1518&h=742&s=599875&e=png&b=fcfcfc)

*   消息位移(Offset)：表示 每个Partition中每条消息的位置信息，是一个单调递增且不会改变的值。
*   消费者位移(Consumer Offset)：表示消费者消费的进度，每个消费者都有自己的消费者位移。
*   消费者组(Consumer Group)：多个消费者实例共同组成的一个消费者组，同时消费多个分区以实现高吞吐量。