---
title: 工作中最常用的 8 种设计模式
source: https://juejin.cn/post/7446964447464390694
author: []
published: 2024-12-11
created: 2024-12-14
description: 
tags:
  - clippings
---


## 前言

设计模式在我们日常的软件开发中无处不在，它们帮助我们编写更易扩展、更具可读性的代码。


## 1\. 单例模式

单例模式确保一个类只有一个实例，通常用于管理共享资源，如配置、缓存、线程池等。

**代码实现：双重检查锁**  
这是单例模式的标准写法，既保证线程安全，又避免性能损耗。

```csharp
public class Singleton {
    private static volatile Singleton instance;

    private Singleton() {}

    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

**JDK 中的应用：**

- `java.lang.Runtime.getRuntime()`
- `java.util.logging.Logger`

**Spring 中的应用：**  
Spring 的 `Bean` 默认是单例模式。可以通过 `@Scope("prototype")` 将其改为多例。

## 2\. 工厂模式

工厂模式用于封装对象的创建逻辑，特别是当类实例化过程复杂时，可以降低耦合度。

**代码实现：简单工厂**  
以支付系统为例，不同支付方式需要不同的对象。

```typescript
public class PaymentFactory {
    public static Payment createPayment(String type) {
        switch (type) {
            case "AliPay":
                return new AliPay();
            case "WeChatPay":
                return new WeChatPay();
            default:
                throw new IllegalArgumentException("Unknown payment type");
        }
    }
}
```

**JDK 中的应用：**

- `java.util.Calendar.getInstance()`
- `javax.xml.parsers.DocumentBuilderFactory.newInstance()`

**Spring 中的应用：**

- `BeanFactory` 和 `ApplicationContext` 都是工厂模式的体现。

## 3\. 策略模式

策略模式将不同算法封装为独立类，并允许在运行时选择不同的策略。

**代码实现：促销策略**  
以电商促销为例，支持满减、打折等多种策略。

```csharp
public interface PromotionStrategy {
    void applyPromotion();
}

public class DiscountStrategy implements PromotionStrategy {
    @Override
    public void applyPromotion() {
        System.out.println("Applying discount...");
    }
}

public class PromotionContext {
    private PromotionStrategy strategy;

    public PromotionContext(PromotionStrategy strategy) {
        this.strategy = strategy;
    }

    public void executePromotion() {
        strategy.applyPromotion();
    }
}
```

**JDK 中的应用：**

- `java.util.Comparator` 是典型的策略模式。

**Spring 中的应用：**

- 事务管理（`TransactionManager`），支持编程式和声明式事务。

## 4\. 代理模式

代理模式通过代理对象控制对目标对象的访问，常用于权限控制、日志记录等场景。

**代码实现：静态代理**  
模拟对一个服务的权限控制。

```csharp
public interface Service {
    void execute();
}

public class RealService implements Service {
    @Override
    public void execute() {
        System.out.println("Executing real service...");
    }
}

public class ServiceProxy implements Service {
    private RealService realService;

    @Override
    public void execute() {
        System.out.println("Checking permissions...");
        if (realService == null) {
            realService = new RealService();
        }
        realService.execute();
    }
}
```

**JDK 中的应用：**

- 动态代理 `java.lang.reflect.Proxy`
- RMI（远程方法调用）

**Spring 中的应用：**

- AOP（面向切面编程）广泛使用代理模式。

## 5\. 观察者模式

观察者模式定义一对多的依赖，当一个对象状态变化时，所有依赖它的对象都会收到通知。

**代码实现：事件通知**  
模拟微博用户的粉丝通知。

```typescript
public interface Observer {
    void update(String message);
}

public class User implements Observer {
    private String name;

    public User(String name) {
        this.name = name;
    }

    @Override
    public void update(String message) {
        System.out.println(name + " received message: " + message);
    }
}

public class Weibo {
    private List<Observer> observers = new ArrayList<>();

    public void follow(Observer observer) {
        observers.add(observer);
    }

    public void post(String message) {
        for (Observer observer : observers) {
            observer.update(message);
        }
    }
}
```

**JDK 中的应用：**

- `java.util.Observer` 和 `java.util.Observable`
- `javax.swing.event.ChangeListener`

**Spring 中的应用：**

- `ApplicationEvent` 和 `ApplicationListener` 是典型实现。

## 6\. 装饰器模式

装饰器模式在不改变原始类的基础上，动态扩展其功能。

**代码实现：咖啡加料**  
模拟一个咖啡订单系统，可以动态加料。

```typescript
public interface Coffee {
    String getDescription();
    double getCost();
}

public class SimpleCoffee implements Coffee {
    @Override
    public String getDescription() {
        return "Simple Coffee";
    }

    @Override
    public double getCost() {
        return 5.0;
    }
}

public class MilkDecorator implements Coffee {
    private Coffee coffee;

    public MilkDecorator(Coffee coffee) {
        this.coffee = coffee;
    }

    @Override
    public String getDescription() {
        return coffee.getDescription() + ", Milk";
    }

    @Override
    public double getCost() {
        return coffee.getCost() + 1.5;
    }
}
```

**JDK 中的应用：**

- `java.io.BufferedInputStream` 和 `java.io.BufferedOutputStream`

**Spring 中的应用：**

- `BeanPostProcessor` 用于动态修改 Bean 的行为。

最近就业形势比较困难，为了感谢各位小伙伴对苏三一直以来的支持，我特地创建了一些工作内推群， 看看能不能帮助到大家。

你可以在群里发布招聘信息，也可以内推工作，也可以在群里投递简历找工作，也可以在群里交流面试或者工作的话题。

添加苏三的**私人微信**：su\_san\_java，备注：**掘金+所在城市**，即可加入。

## 7\. 模板方法模式

模板方法模式定义一个算法的骨架，把具体的实现留给子类。

**代码实现：任务执行模板**  
模拟定时任务的执行流程。

```csharp
public abstract class Task {
    public final void execute() {
        init();
        doWork();
        cleanup();
    }

    protected abstract void init();
    protected abstract void doWork();
    protected void cleanup() {
        System.out.println("Default cleanup...");
    }
}

public class DataProcessingTask extends Task {
    @Override
    protected void init() {
        System.out.println("Initializing data...");
    }

    @Override
    protected void doWork() {
        System.out.println("Processing data...");
    }
}
```

**JDK 中的应用：**

- `java.util.AbstractList` 和 `java.util.AbstractMap`

**Spring 中的应用：**

- `JdbcTemplate` 和 `RestTemplate`

## 8\. 建造者模式

建造者模式用于创建复杂对象，特别是当对象有多个可选参数时。

**代码实现：构建 HTTP 请求**

```kotlin
public class HttpRequest {
    private String method;
    private String url;
    private String body;

    private HttpRequest(Builder builder) {
        this.method = builder.method;
        this.url = builder.url;
        this.body = builder.body;
    }

    public static class Builder {
        private String method;
        private String url;
        private String body;

        public Builder method(String method) {
            this.method = method;
            return this;
        }

        public Builder url(String url) {
            this.url = url;
            return this;
        }

        public Builder body(String body) {
            this.body = body;
            return this;
        }

        public HttpRequest build() {
            return new HttpRequest(this);
        }
    }
}
```

**JDK 中的应用：**

- `StringBuilder`
- `Stream.Builder`

**Spring 中的应用：**

- `UriComponentsBuilder` 用于构建 URI。

