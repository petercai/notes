# Event Driven 2.0
The amount of data that needs to be processed, filtered, connected, and stored is constantly growing. Companies that can process the data quickly have an advantage. Ideally, it should happen in real-time. Event-driven architectures are used for this.

Such architectures allow exchanging messages in real-time, storing them in a single database, and using distributed systems for sending and processing messages.

In this article, we will talk about how event-driven architecture differs from other popular message-driven architecture. In addition, we will learn the most popular event-driven architecture patterns, and their main advantages and disadvantages.

Event-Driven vs. Message-Driven Architecture
--------------------------------------------

An **event** is some action that took place at a certain point in time. It is generated by the service and does not have specific recipients. Any system component can be an event consumer.

A **message** is a fixed packet of data that is sent from one service to another. An event is a type of message that signals a change in the state of the system.

In an **event-driven architecture**, the component that generates the event tells other components where it will be stored. That way, any component can save, process, and respond to an event, and the producer won’t know who the consumer is.

In **message-driven systems**, components that create messages send them to a specific address. After sending a message, the component immediately receives control and does not wait for the message to be processed.

In a message-driven architecture, if a similar message needs to be sent to multiple recipients, the sender must send it to each recipient separately. In contrast, in an event-driven architecture, a producer generates an event once and sends it to a processing system/ After that, the event can be consumed by any number of subscribers connecting to that system.

Event-Driven Patterns
---------------------

There are different approaches to implementing an event-driven architecture. Often, when designing a program, several approaches are used together. In this section, we will talk about the most popular patterns that allow you to implement an event-driven architecture, their advantages, and their application areas.

Global Event Streaming Platform
-------------------------------

It is vital for today’s companies to respond to events in real-time. Customers expect the business to respond immediately to various events. So, there is a need to develop such software architectures that will meet modern business requirements and will be able to process data as event streams, and not only data that is in a state of rest.

A great solution is to use a global event streaming platform. It allows you to process business functions as event streams. In addition, this platform is fault-tolerant and scalable.

All events that occur in the system are recorded in the data streaming platform once. External systems read these events and process them in real time.

Event streaming platforms consist of a diverse set of components. Their creation requires significant resources and engineering experience. Such a pattern is quite popular and is used in many industries.

Central Event Store
-------------------

The central event store ensures the publication and storage of events in a single database. It is a single endpoint for events of various types. This allows applications and services to respond to events in real-time without delays or data loss. Applications can easily subscribe to a variety of events, reducing development costs.

The central event store is used for a variety of purposes:

*   Publication of changes for consumer services.
*   Reconstruction of past states and conducting business analytics.
*   Search for events.
*   Saving all program changes as a sequence of events.
*   A single endpoint for notification based on application state changes.
*   Monitoring system status.

Using a central event store, you can create new applications and use existing events without having to republish them.

Event-First and Event Streaming Applications
--------------------------------------------

[Event streaming](https://thenewstack.io/event-streaming-and-event-sourcing-the-key-differences/) allows you to receive data from various sources, such as applications, databases, various sensors, Internet devices, etc., process, clean, and use them without first saving them. This method of event processing provides fast results and is very important for companies that transfer large amounts of data and require to receive information quickly.

Key benefits of event streaming platforms:

*   **Improving the customer experience:** Customers can instantly learn about changes in the status of their orders, which improves their experience and, accordingly, increases the company’s income.
*   **Risk reduction:**Systems that use streaming events allow the detection of fraud on the Internet, can stop a suspicious transaction, or block a card.
*   **Reliability:** Event streaming platforms allow for robust systems that can effectively handle subscriber failures.
*   **Feedback in real time:** Users can see the results of their operations immediately after their execution, without waiting a minute.

Event streaming systems require less infrastructure and data to support, so they are simple and fast to build.

Applications that use this architecture pattern are used in various industries, such as financial trading, risk and fraud detection in financial systems, the Internet of Things, retail, etc.

CQRS
----

[Command Query Responsibility Segregation](https://learn.microsoft.com/en-us/azure/architecture/patterns/cqrs) (CQRS) is the principle of separating data structures for reading and writing information. It is used to increase the performance, security, and scalability of the software.

The application of CQRS is quite useful in complex areas where a single model for reading and writing data is too complex. When it is separated, it is greatly simplified. This is especially noticeable when the number of reading and writing operations is significantly different.

Different databases can be used for reading and storing data. In this case, they must be synchronized. To do this, the recording model must publish an event every time it updates the database.

Advantages of CQRS:

*   Independent scaling of reading and write workloads.
*   Separate optimized data schemes for reading and writing.
*   The use of more flexible and convenient models thanks to the separation of concerns.
*   Ability to avoid complex queries by storing the materialized view in the read database.

The CQRS template is useful for the following scenarios:

*   In systems where many users simultaneously access the same data.
*   When data read performance should be configured separately from data write performance. This is especially important when the number of reads greatly exceeds the number of writes.
*   When the read-and-write models are created by different development teams.
*   With frequent changes in business rules.

In cases where the logic of the system and the user interface are quite simple, this template is not recommended.

Event Sourcing
--------------

An [event sourcing](https://learn.microsoft.com/en-us/azure/architecture/patterns/event-sourcing) stores the system state as a sequence of events. Whenever the system state changes, a new event is added to the event list. However, this system state can be restored by reprocessing events in the future. All events are stored in the event store, which is an event database.

A good example of such an architecture is a version control system. Its event store is a log of all commits, and a working copy of the source tree is the system state.

The main advantages of event search:

*   Events can be published each time the system state changes.
*   Ensuring a reliable change audit log.
*   The ability to determine the state of the system at any time.
*   The ability to easily transition from a monolithic application to a microservice architecture through the use of loosely coupled objects that exchange events.

However, to reconstruct the state of business objects, you need to send standard requests, which is difficult and inefficient. Therefore, the system must use Command Request Responsibility Distribution (CQRS) to implement requests. This means that applications must process the final agreed-upon data.

Automated Data Provisioning
---------------------------

This pattern provides fully self-service data provisioning. The user must determine what data and in what format he needs, as well as where it should be stored. For example, in a database, distributed cache, microservice, etc. The selected repository can be used together with the central repository.

The system provides the client with infrastructure along with pre-loaded data and manages the flow of events. The processor processes and filters data streams according to user requirements. The use of cloud infrastructure makes such a system faster and more practical.

Systems that use automated data provisioning are used in finance, retail, and the Internet, both on-premises and in the cloud.

Advantages and Disadvantages of Event-Driven Architecture
---------------------------------------------------------

Even though event-driven architecture is quite popular now, is developing rapidly, and helps to solve many business problems, there are also some [disadvantages](https://www.neebal.com/blog/advantages-and-disadvantages-of-event-driven-architecture) of using this approach. In this section, we list the main [advantages and disadvantages](https://www.techtarget.com/searchapparchitecture/tip/Event-driven-architecture-pros-and-cons-Is-EDA-worth-it) of event-driven architecture.

### Advantages

*   **Autonomy:** The loose coupling of components that use this architecture allows event producers and consumers to function independently of each other. This connection allows you to use different programming languages and technologies to develop different components. In addition, producers and consumers can be added and removed from the system without affecting other participants.
*   **Fault tolerance:** Events are published immediately after they occur. Various services and programs subscribe to these events. If the consumer shuts down, events continue to be published and queued. When the consumer reconnects, it will be able to handle these events.
*   **Real-time user interaction** for a better user experience.
*   **Economy:** The consumer receives the message immediately after the producer has published it, eliminating the need for constant polling to verify the event. This reduces CPU consumption and network bandwidth usage.

### Disadvantages

*   Error handling is difficult. Because event producers and consumers can be many and loosely connected, it is difficult to trace the actions between them and identify the root cause of a malfunction.
*   Inability to predict events occurring in different periods. Since events are asynchronous, the order in which they occur cannot be predicted. Additionally, there may be duplicates, each of which may require a contextual response. This requires additional testing time and deep system analysis to prevent data loss.
*   The weak connection between the systems that generate the events and the systems that receive them can be a point of vulnerability that attackers can exploit.

Conclusion
----------

Event-driven architectures have been around for a long time and were used to pass messages. In connection with modern business needs, they are actively developing and offering better opportunities for connection and management. Event-driven architectures are indispensable for real-time event processing, as required by many modern systems.

To implement such an architecture, there are several different patterns, each of which has its advantages and application features. When designing a system, you need to clearly define its functions and applications to choose the right pattern.

Although event-driven architecture is widely used and has many advantages, its features can sometimes have a bad effect on the system, which must be taken into account during its design.