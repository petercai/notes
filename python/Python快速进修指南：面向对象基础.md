# Python快速进修指南：面向对象基础
当我深入学习了面向对象编程之后，我首先感受到的是代码编写的自由度大幅提升。不同于Java中严格的结构和约束，Python在面向对象的实现中展现出更加灵活和自由的特性。它使用了一些独特的关键字，如self和cls，这些不仅增强了代码的可读性，还提供了对类和实例的明确引用。正如Java，Python也依赖于对象和类的概念，允许我们通过定义类来创建和操作对象。尽管在表面上Python和Java在面向对象的实现上看似相似，但实际上，它们在细节处理上存在一些显著的差异。接下来，我们将探索这些差异，并深入了解它们在实际应用中的具体表现，以便更好地理解面向对象编程在不同语言中的独特风格和优势。

首先，你需要声明一个类。在Python中，这通常是通过使用class关键字来完成的。下面是一个简单的类声明的示例：

```python
class MyClass:
    myAttr = "类的属性"
    def __init__(self, attribute):
        self.attribute = attribute

    def my_method(self):
        return f"Value of attribute is {self.attribute}"

```

关于上面的类声明你可能发现了attribute和myAttr属性不一样，不报错吗？这就是Python的特点：动态属性赋值。在Python中，不仅可以在类的初始化方法\_\_init\_\_中直接定义新的属性，还可以在对象创建之后的任何时刻动态地添加属性，这种做法在Java中会引发错误，但在Python中却是完全合法的，反映了其动态类型的本质。下面再详细说下。

在Java中，this关键字是隐式的，用于指代当前对象的实例，而在Python中，self必须显式声明并作为方法的第一个参数传递。

返回值里的`f`在这里表示格式化，它使得在字符串中直接嵌入表达式成为可能。Python会自动进行求值并将结果转换为字符串。

创建对象
----

一旦定义了类，就可以使用该类来创建对象。这是通过简单地调用类名并传递必要的参数来完成的。例如：

```python
my_object = MyClass("Hello")
my_object.subAttr = "是子类的"
print(my_object.subAttr) 
print(my_object.my_method()) 

```

虽然在Python中，self关键字需要显式地在方法定义中指出，但其实它的作用与Java中的this关键字相似，代表着方法所属的对象实例。在调用实例方法时，Python会自动将对象实例作为第一个参数传递给self，因此在正常使用实例方法时，我们无需显式地传递这个参数。例如，在调用my\_object.my\_method()时，my\_object实例会自动作为self参数传递给my\_method。这种机制确保了方法能够访问和操作所属对象实例的数据。

如果尝试直接通过类名来调用实例方法，如MyClass.my_method()，将会引发错误。这是因为没有提供必要的实例参数，导致self没有被正确初始化。要想通过类名调用方法，方法必须是类方法或静态方法。来看下

类方法和静态方法
--------

在Python中，@classmethod和@staticmethod是两种常用的方法装饰器，它们分别用于定义类方法和静态方法。

其特点是第一个参数通常是cls，代表着类本身。这与实例方法中的self参数相似，但有一个重要的区别：cls参数指向类，而不是类的某个特定实例。类方法的一个限制是它们无法访问特定实例的属性，因为它们不与任何实例绑定。

```python
class MyClass:
    @classmethod
    def my_class_method(cls):
        
        return "这是一个类方法"

```

静态方法实际上是独立于类的实例和类本身的。静态方法不接收传统意义上的self或cls参数，这意味着它们既不能访问类的实例属性（即对象级别的数据），也不能访问类属性（即与类本身相关联的数据）。静态方法的这种特性使得它们更像是普通函数，但为了逻辑上的整洁和组织性，它们被放置在类的定义中。

```python
class MyClass:
    @staticmethod
    def my_static_method():
        return "这是一个静态方法"

```

作为一名有着Java背景的开发者，你无疑已经习惯了Java那严格的类型系统和细致的访问控制机制。转向Python，你会发现一个截然不同的编程世界。Python的面向对象编程（OOP）方式为代码组织提供了更高的自由度和灵活性，这种变化可能会给你带来新鲜感，同时也是一个挑战。需要注意的是，Python的这种灵活性可能会导致更少的编译时错误检查。由于Python是一种解释型语言，很多错误只有在运行时才会被捕捉到。